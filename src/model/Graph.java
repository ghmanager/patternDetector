package model;

import java.util.ArrayList;
import java.util.List;

import controller.GraphException;
import controller.PatternType;

/**
 * This class represents an implementable Graph with vertices and edges in between them.
 * @author Alexis T. Bernhard
 *
 */
class Graph implements ReadableGraph {

	/**
	 * The internal list of vertices which are part of the graph.
	 */
	private List<ModifiableVertex> vertices;

	/**
	 * The internal matrix of edges, which are part of the graph
	 */
	private double[][] edges;

	/**
	 * The internal matrix of edges to pods of the same replica-set, which are part of the graph.
	 */
	private double[][] replicaEdges;

	/**
	 * The internal type of pattern this graph is represented.
	 * This field is just set for graphs generated by the pattern detector and is otherwise null.
	 */
	private PatternType pattern;

	/**
	 * An array of role appearances to store how many nodes with a certain role are part of the graph.
	 */
	private int[] roleAppearances;

	/**
	 * This boolean indicates if all vertices are known.
	 * When it is true, it indicates that the edge matrix can be filled but no more vertices can be added or removed.
	 */
	private boolean fixedGraph = false;

	@Override
	public List<ModifiableVertex> getVertices() {
		return vertices;
	}

	@Override
	public ModifiableVertex getVertexByName(String name) {
		ModifiableVertex resvertex = null;
		for (ModifiableVertex vertex : vertices) {
			if (vertex.getName().equals(name))
				resvertex = vertex;
		}
		return resvertex;
	}

	@Override
	public ModifiableVertex getVertexByIndex(int index) {
		if (index < 0 || index >= vertices.size()) {
			return null;
		} else {
			return vertices.get(index);
		}
	}

	@Override
	public double[][] getAdjacencyMatrix() {
		return edges;
	}

	/**
	 * Gets the replica adjacency matrix of the graph containing all edges
	 * @return the replica adjacency matrix
	 */
	public double[][] getReplicaAdjacencyMatrix() {
		return replicaEdges;
	}

	@Override
	public int getConnectionByIndex(int vertex1, int vertex2) {
		if (vertex1 < 0 || vertex1 >= vertices.size() || vertex2 < 0 || vertex2 >= vertices.size()) {
			return -1;
		}
		int result = 0;
		if (edges[vertex1][vertex2] > 0) {
			result++;
		}
		if (edges[vertex2][vertex1] > 0) {
			result += 2;
		}
		return result;
	}



	@Override
	public PatternType getPattern() {
		return pattern;
	}

	@Override
	public int[] getAllRoleAppearances() {
		return this.roleAppearances;
	}

	@Override
	public int getRoleAppearance(String role) {
		int i = pattern.getRoleIndex(role);
		if (i < 0) {
			return -1;
		} else {
			return this.roleAppearances[i];
		}
	}

	@Override
	public int getRoleAppearance(int index) throws GraphException {
		if (index >= 0 && index < roleAppearances.length) {
			return this.roleAppearances[index];
		} else {
			throw new GraphException("The role of a vertex of an output graph does not exist.");
		}
	}

	/**
	 * Initializes a graph by initializing its internal vertex list
	 */
	Graph() {
		vertices = new ArrayList<>();
	}

	/**
	 * This method adds a vertex to the vertex list of the graph, if the graph is not fixed yet.
	 * @param vertex the vertex to add
	 * @throws GraphException thrown if the vertex to add can not be added due to a fixed graph.
	 */
	void addVertex(ModifiableVertex vertex) throws GraphException {
		if (!fixedGraph) {
			vertices.add(vertex);
		} else {
			throw new GraphException("Adding a vertex to the graph failed: Adjacency matrix set. Please remove the adjacency matrix.");
		}
	}

	/**
	 * This method removes the first occurrence of the input vertex in the vertex list of the graph, if the graph is not fixed yet.
	 * @param vertex the vertex to remove
	 * @throws GraphException thrown if the vertex to remove can not be added due to a fixed graph.
	 */
	void removeVertex(ModifiableVertex vertex) throws GraphException {
		if(!fixedGraph) {
			vertices.remove(vertex);
		} else {
			throw new GraphException("Removing a vertex to the graph failed: Adjacency matrix set. Please remove the adjacency matrix.");
		}
	}

	/**
	 * Generates the adjacency matrix of the graph
	 * Warning: After using this no vertices can be added to the Graph (reset adjacency matrix to add more vertices)
	 * @param size the final size of the adjacency matrix of the graph (equals the size of the vertex list)
	 */
	void generateAdjacencyMatrices() {
		edges = new double[vertices.size()][vertices.size()];
		replicaEdges = new double[vertices.size()][vertices.size()];
		fixedGraph = true;
	}

	/**
	 * This method removes the adjacency matrix and allows to add more vertices to the graph, please regenerate the adjacency matrix.
	 */
	void removeAdjacencyMatrix() {
		fixedGraph = false;
		edges = new double[0][0];
	}

	/**
	 * Add an edge to the graph
	 * @param source the source vertex as starting point of the edge
	 * @param type the type of the application, 1 = replicaset edge
	 * @throws GraphException thrown if one of the input vertices is badly defined
	 */
	void addEdge(ModifiableVertex source, ModifiableVertex dest, int type) throws GraphException {
		if (source == null || dest == null) {
			throw new GraphException("The edge creation failed due to a inserted null vertex.");
		} else {
			this.addEdgeByIndex(source.getIndex(), dest.getIndex(), type);
		}
	}

	/**
	 * Add an edge to the graph by an index
	 * @param source the source index of the vertex in the vertex list
	 * @param dest the destination index of the vertex in the vertex list
	 * @param type the type of the application, 1 = replicaset edge
	 * @throws GraphException thrown if one of the input vertices is badly defined
	 */
	void addEdgeByIndex(int sourceIndex, int destIndex, int type) throws GraphException {
		if (sourceIndex < 0 || sourceIndex >= vertices.size()||
				destIndex < 0 || destIndex >= vertices.size() ||
				sourceIndex == destIndex) {
			throw new GraphException("The edge creation failed due to a badly defined input vertex index or a self pointing edge.");
		} else {
			edges[sourceIndex][destIndex] = 1.0;
			if (type == 1)
				replicaEdges[sourceIndex][destIndex] = 1.0;
		}
	}

	/**
	 * Removes an edge of the graph
	 * @param source the source vertex as starting point of the edge
	 * @param dest the destination vertex of the edge
	 * @param type the type of the application, 1 = replicaset edge
	 * @throws GraphException thrown if one of the input vertices is badly defined
	 */
	void removeEdge(ModifiableVertex source, ModifiableVertex dest, int type) throws GraphException {
		if (source == null || dest == null ||
				source.getIndex() < 0 || source.getIndex() >= vertices.size()||
				dest.getIndex() < 0 ||  dest.getIndex() >= vertices.size() ||
				source.getIndex() ==  dest.getIndex()) {
			throw new GraphException("The edge deletion failed due to a badly defined input vertex index or a self pointing edge.");
		} else {
			edges[source.getIndex()][dest.getIndex()] = 0.0;
			if (type == 1)
				replicaEdges[source.getIndex()][dest.getIndex()] = 0.0;
		}
	}

	/**
	 * Sets the pattern of the graph
	 * @param pattern the pattern of the graph
	 */
	void setPattern(PatternType pattern) {
		this.pattern = pattern;
	}

	/**
	 * Initializes the role appearance array
	 */
	void initRoleAppearances() {
		roleAppearances = new int[this.getPattern().getRoles().length];
	}

	/**
	 * Increase the role appearance of the role at the given index
	 * @param index the index in the role list of the pattern
	 * @throws GraphException thrown if the requested index is out of bounds
	 */
	void increaseRoleAppearance(int index) throws GraphException {
		if (index >= 0 && index < roleAppearances.length) {
			roleAppearances[index]++;
		} else {
			throw new GraphException("The role of a vertex of an output graph does not exist.");
		}
	}

	/**
	 * Clears a graph by deleting all vertices, edges, unfix graph and reset the pattern.
	 */
	void clear() {
		pattern = null;
		edges = null;
		fixedGraph = false;
		roleAppearances = null;
		vertices.clear();
	}
}
